import axios from 'axios';
import { Vulnerability } from '@shared/schema';

export interface VulnerabilitySource {
  name: string;
  fetchVulnerabilities(packageName: string, version?: string): Promise<Vulnerability[]>;
}

export interface OSVVulnerability {
  id: string;
  summary: string;
  details: string;
  severity?: Array<{
    type: string;
    score: string;
  }>;
  affected: Array<{
    package: {
      name: string;
      ecosystem: string;
    };
    ranges: Array<{
      type: string;
      events: Array<{
        introduced?: string;
        fixed?: string;
      }>;
    }>;
    versions?: string[];
  }>;
  references: Array<{
    type: string;
    url: string;
  }>;
  database_specific?: {
    severity?: string;
    cwe_ids?: string[];
  };
}

export interface GitHubAdvisory {
  ghsa_id: string;
  cve_id?: string;
  summary: string;
  description: string;
  severity: string;
  identifiers: Array<{
    type: string;
    value: string;
  }>;
  references: Array<{
    url: string;
  }>;
  published_at: string;
  updated_at: string;
  vulnerabilities: Array<{
    package: {
      name: string;
      ecosystem: string;
    };
    vulnerable_version_range: string;
    patched_versions: string[];
    unaffected_versions: string[];
  }>;
}

export class OSVService implements VulnerabilitySource {
  name = 'OSV (Open Source Vulnerabilities)';
  private baseUrl = 'https://api.osv.dev/v1';

  async fetchVulnerabilities(packageName: string, version?: string): Promise<Vulnerability[]> {
    try {
      const response = await axios.post(`${this.baseUrl}/query`, {
        package: {
          name: packageName,
          ecosystem: 'npm'
        },
        version: version
      }, {
        timeout: 10000,
        headers: {
          'Content-Type': 'application/json'
        }
      });

      return response.data.vulns?.map((vuln: OSVVulnerability) => this.convertOSVToVulnerability(vuln, packageName)) || [];
    
    } catch (error) {
      console.error(`OSV API error for ${packageName}:`, error.message);
      return [];
    }
  }

  /**
   * Fetch vulnerabilities for multiple packages and versions.
   * Accepts a dependencies object: { [packageName]: version }
   * Returns a map of package name to Vulnerability[].
   * Uses fetchVulnerabilities (serially) instead of bulk-query.
   */
  async fetchMultiplePackagesWithVersionsBatch(
    dependencies: Record<string, string>
  ): Promise<Record<string, Vulnerability[]>> {
    const results: Record<string, Vulnerability[]> = {};
    for (const [name, version] of Object.entries(dependencies)) {
      results[name] = await this.fetchVulnerabilities(name, version);
    }
    return results;
  }

  private convertOSVToVulnerability(osv: OSVVulnerability, packageName: string): Vulnerability {
    const severity = this.determineSeverity(osv);
    const affectedPackage = osv.affected.find(a => a.package.name === packageName);
    // Extract CVE from id or aliases if present
    return {
      id: osv.id,
      package: packageName,
      version: affectedPackage?.versions?.[0] || 'unknown',
      severity,
      description: osv.summary || osv.details || 'No description available',
      cve: this.extractCVE(osv.id, osv.aliases || []),
      cvss: this.extractCVSS(osv.severity),
      fixedIn: this.extractFixedVersion(affectedPackage),
    };
  }

  // Accepts id and aliases array, returns id if it's a CVE, otherwise first CVE alias if present
  private extractCVE(id: string, aliases: string[]): string | undefined {
    if (id && id.startsWith('CVE-')) return id;
    if (Array.isArray(aliases)) {
      const found = aliases.find(alias => alias.startsWith('CVE-'));
      if (found) return found;
    }
    return undefined;
  }

  private determineSeverity(osv: OSVVulnerability): 'critical' | 'high' | 'moderate' | 'low' {
    const severity = osv.database_specific?.severity || 
                    osv.severity?.[0]?.score || 
                    'unknown';
    
    const severityLower = severity.toLowerCase();
    if (severityLower.includes('critical')) return 'critical';
    if (severityLower.includes('high')) return 'high';
    if (severityLower.includes('moderate') || severityLower.includes('medium')) return 'moderate';
    return 'low';
  }

  private extractCVSS(severity?: Array<{ type: string; score: string }>): number | undefined {
    const cvssScore = severity?.find(s => s.type === 'CVSS_V3')?.score;
    return cvssScore ? parseFloat(cvssScore) : undefined;
  }

  private extractFixedVersion(affected?: any): string | undefined {
    const fixEvent = affected?.ranges?.[0]?.events?.find((e: any) => e.fixed);
    return fixEvent?.fixed;
  }
}

class GitHubAdvisoryService implements VulnerabilitySource {
  name = 'GitHub Security Advisory Database';
  private baseUrl = 'https://api.github.com/advisories';

  async fetchVulnerabilities(packageName: string, version?: string): Promise<Vulnerability[]> {
    try {
      const params = new URLSearchParams({
        ecosystem: 'npm',
        package: packageName,
        per_page: '100'
      });

      const response = await axios.get(`${this.baseUrl}?${params}`, {
        timeout: 10000,
        headers: {
          'Accept': 'application/vnd.github+json',
          'User-Agent': 'DepGuard-AI/1.0'
        }
      });

      return response.data.map((advisory: GitHubAdvisory) => 
        this.convertGitHubToVulnerability(advisory, packageName)
      );
    } catch (error) {
      console.error(`GitHub Advisory API error for ${packageName}:`, error.message);
      return [];
    }
  }

  private convertGitHubToVulnerability(advisory: GitHubAdvisory, packageName: string): Vulnerability {
    const vulnerability = advisory.vulnerabilities.find(v => v.package.name === packageName);
    
    return {
      id: advisory.ghsa_id,
      package: packageName,
      version: vulnerability?.vulnerable_version_range || 'unknown',
      severity: this.mapGitHubSeverity(advisory.severity),
      description: advisory.summary || advisory.description,
      cve: advisory.cve_id,
      fixedIn: vulnerability?.patched_versions?.[0],
    };
  }

  private mapGitHubSeverity(severity: string): 'critical' | 'high' | 'moderate' | 'low' {
    switch (severity?.toLowerCase()) {
      case 'critical': return 'critical';
      case 'high': return 'high';
      case 'moderate': return 'moderate';
      case 'low': return 'low';
      default: return 'low';
    }
  }
}

class SnykService implements VulnerabilitySource {
  name = 'Snyk Vulnerability Database';
  private baseUrl = 'https://snyk.io/api/v1';

  async fetchVulnerabilities(packageName: string, version?: string): Promise<Vulnerability[]> {
    try {
      // Using Snyk's public vulnerability database
      const response = await axios.get(`https://security.snyk.io/package/npm/${packageName}`, {
        timeout: 10000,
        headers: {
          'Accept': 'application/json',
          'User-Agent': 'DepGuard-AI/1.0'
        }
      });

      // Note: This would need Snyk API key for full access
      // For now, we'll parse the public data available
      return this.parseSnykResponse(response.data, packageName);
    } catch (error) {
      console.error(`Snyk API error for ${packageName}:`, error.message);
      return [];
    }
  }

  private parseSnykResponse(data: any, packageName: string): Vulnerability[] {
    // This is a simplified parser for Snyk's public data
    // In production, you'd use their official API with proper authentication
    return [];
  }
}

export class RealtimeVulnerabilityService {
  private sources: VulnerabilitySource[] = [
    new OSVService(),
   // new GitHubAdvisoryService(),
    // new SnykService(), // Uncomment when Snyk API key is available
  ];

  async fetchVulnerabilitiesForPackages(packages: Record<string, string>): Promise<Vulnerability[]> {
    const allVulnerabilities: Vulnerability[] = [];
    const processedIds = new Set<string>();

    for (const [packageName, version] of Object.entries(packages)) {
      console.log(`Fetching vulnerabilities for ${packageName}@${version}`);
      
      for (const source of this.sources) {
        try {
          const vulnerabilities = await source.fetchVulnerabilities(packageName, version);
          
          // Deduplicate vulnerabilities
          for (const vuln of vulnerabilities) {
            const uniqueId = `${vuln.package}-${vuln.id}`;
            if (!processedIds.has(uniqueId)) {
              processedIds.add(uniqueId);
              allVulnerabilities.push(vuln);
            }
          }
        } catch (error) {
          console.error(`Error fetching from ${source.name} for ${packageName}:`, error.message);
        }
      }
    }

    return allVulnerabilities;
  }

  async fetchVulnerabilitiesForSinglePackage(packageName: string, version?: string): Promise<Vulnerability[]> {
    const allVulnerabilities: Vulnerability[] = [];
    const processedIds = new Set<string>();

    for (const source of this.sources) {
      try {
        const vulnerabilities = await source.fetchVulnerabilities(packageName, version);
        
        for (const vuln of vulnerabilities) {
          const uniqueId = `${vuln.package}-${vuln.id}`;
          if (!processedIds.has(uniqueId)) {
            processedIds.add(uniqueId);
            allVulnerabilities.push(vuln);
          }
        }
      } catch (error) {
        console.error(`Error fetching from ${source.name} for ${packageName}:`, error.message);
      }
    }

    return allVulnerabilities;
  }

  async checkPackageHealth(packageName: string): Promise<{
    hasVulnerabilities: boolean;
    vulnerabilityCount: number;
    lastChecked: Date;
    sources: string[];
  }> {
    const vulnerabilities = await this.fetchVulnerabilitiesForSinglePackage(packageName);
    
    return {
      hasVulnerabilities: vulnerabilities.length > 0,
      vulnerabilityCount: vulnerabilities.length,
      lastChecked: new Date(),
      sources: this.sources.map(s => s.name)
    };
  }
}

export const realtimeVulnerabilityService = new RealtimeVulnerabilityService();